// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  PLAYER
}

enum GameStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum GameType {
  REGULAR    // Anyone can join, max 8 players
  FRIENDS    // Friends can join, max 8 players
  ONE_VS_ONE // 1v1 game, 2 players
}

model User {
  id                 String   @id @default(uuid())
  email              String?  @unique
  username           String   @unique
  walletAddress      String   @unique
  role               UserRole @default(PLAYER)
  passwordHash       String? // Optional for wallet-only auth
  blastwheelzBalance Decimal  @default(0) @db.Decimal(18, 8) // In-game currency balance
  isActive           Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  gameSessions         GameSession[]
  transactions         Transaction[]
  playerStats          PlayerStats?
  marketplacePurchases MarketplacePurchase[]
  leaderboardEntries   LeaderboardEntry[]

  @@index([walletAddress])
  @@index([email])
  @@index([role])
}

model PlayerStats {
  id            String   @id @default(uuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  totalGames    Int      @default(0)
  wins          Int      @default(0)
  losses        Int      @default(0)
  totalEarnings Decimal  @default(0) @db.Decimal(18, 8)
  totalSpent    Decimal  @default(0) @db.Decimal(18, 8)
  rank          Int      @default(0)
  level         Int      @default(1)
  experience    Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([rank])
  @@index([level])
}

model GameSession {
  id            String     @id @default(uuid())
  userId        String
  user          User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  status        GameStatus @default(PENDING)
  gameType      GameType   @default(REGULAR)
  entryFee      Decimal    @db.Decimal(18, 8)
  prizePool     Decimal    @default(0) @db.Decimal(18, 8)
  position      Int?
  earnings      Decimal    @default(0) @db.Decimal(18, 8)
  transactionId String?
  gameId        String? // Reference to the game room/lobby
  metadata      Json? // Additional game data (e.g., friend IDs for FRIENDS games)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  completedAt   DateTime?

  // Relations
  leaderboardEntries LeaderboardEntry[]

  @@index([userId])
  @@index([status])
  @@index([gameType])
  @@index([gameId])
  @@index([createdAt])
}

model LeaderboardEntry {
  id            String   @id @default(uuid())
  gameType      GameType
  gameSessionId String?
  gameSession   GameSession? @relation(fields: [gameSessionId], references: [id], onDelete: SetNull)
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  username      String   // Denormalized for performance
  walletAddress String   // Denormalized for performance
  position      Int      // Final position in the game (1 = winner)
  score         Decimal  @default(0) @db.Decimal(18, 8) // Game score/points
  earnings      Decimal  @default(0) @db.Decimal(18, 8) // Prize earnings
  entryFee      Decimal  @db.Decimal(18, 8)
  gameId        String? // Reference to the game room/lobby
  metadata      Json? // Additional game data (lap times, best time, etc.)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([gameType])
  @@index([userId])
  @@index([gameId])
  @@index([position])
  @@index([score])
  @@index([createdAt])
  // Note: Unique constraint on gameId is handled in application logic since gameId can be null
}

model Transaction {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String // DEPOSIT, WITHDRAWAL, GAME_ENTRY, GAME_REWARD, PURCHASE, CURRENCY_PURCHASE, NFT_PURCHASE
  amount    Decimal  @db.Decimal(18, 8)
  suiTxHash String?  @unique
  status    String   @default("PENDING") // PENDING, COMPLETED, FAILED
  metadata  Json? // Additional transaction data
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([suiTxHash])
  @@index([type])
  @@index([status])
  @@index([createdAt])
}

model NFT {
  id           String   @id @default(uuid())
  tokenId      String   @unique
  ownerAddress String
  collectionId String?
  name         String
  description  String? // Optional description (can be derived from name)
  imageUrl     String? // Maps to image_url in Move contract
  projectUrl   String? // Maps to project_url in Move contract
  mintNumber   Int? // Maps to mint_number in Move contract (u64)
  alloyRim     String? // Maps to alloy_rim in Move contract
  frontBonnet  String? // Maps to front_bonnet in Move contract
  backBonnet   String? // Maps to back_bonnet in Move contract
  creator      String? // Creator address from Move contract
  metadata     Json? // Additional metadata
  suiObjectId  String   @unique
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([ownerAddress])
  @@index([tokenId])
  @@index([suiObjectId])
  @@index([creator])
  @@index([mintNumber])
}

enum MarketplaceItemStatus {
  ACTIVE
  INACTIVE
  SOLD_OUT
}

enum MarketplaceItemType {
  NFT
  ITEM
  UPGRADE
  CURRENCY
  OTHER
}

model MarketplaceItem {
  id          String                @id @default(uuid())
  name        String
  description String?
  imageUrl    String?
  price       Decimal               @db.Decimal(18, 8) // Price in blastwheelz
  status      MarketplaceItemStatus @default(ACTIVE)
  type        MarketplaceItemType   @default(ITEM)
  stock       Int? // null = unlimited, number = limited stock
  soldCount   Int                   @default(0) // Track how many sold
  category    String? // Optional category for filtering
  metadata    Json? // Additional item data (e.g., NFT details, upgrade specs)
  createdBy   String // Admin user ID who created this
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt

  // Relations
  purchases MarketplacePurchase[]

  @@index([status])
  @@index([type])
  @@index([category])
  @@index([createdBy])
  @@index([createdAt])
}

model MarketplacePurchase {
  id        String          @id @default(uuid())
  itemId    String
  item      MarketplaceItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  userId    String
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  price     Decimal         @db.Decimal(18, 8) // Price at time of purchase
  quantity  Int             @default(1)
  metadata  Json? // Additional purchase data
  createdAt DateTime        @default(now())

  @@index([itemId])
  @@index([userId])
  @@index([createdAt])
}
